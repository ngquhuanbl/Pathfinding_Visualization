{"version":3,"sources":["constants/algorithms/maze-generation.ts","utils/algorithms/maze-generation/recursiveDivisionEqual.ts","utils/algorithms/maze-generation/recursiveDivisionNonEqual.ts","utils/algorithms/maze-generation/basicRandomWall.ts","utils/algorithms/maze-generation/basicRandomDesert.ts","utils/data-structures/queue/Queue.ts","utils/grid.ts","utils/algorithms/path-finding/bfs.ts","utils/algorithms/path-finding/earlyExitBFS.ts","utils/data-structures/queue/PriorityQueue.ts","constants/algorithms/path-finding.ts","utils/algorithms/path-finding/dijkstra.ts","utils/algorithms/path-finding/greedyBestFirstSearch.ts","utils/algorithms/path-finding/aStar.ts","constants/drawing.ts","utils/data-structures/location/GridLocation.ts","utils/delay.ts","constants/delay.ts","constants/speed.ts","utils/device-checking.ts","utils/path-construct.ts","views/components/Footer/FooterControls/index.tsx","views/components/Footer/Legends/index.tsx","views/components/Footer/index.tsx","views/components/Grid/Cell/index.tsx","views/components/Grid/index.tsx","assets/logo.svg","views/components/Header/Logo/index.tsx","views/components/Header/index.tsx","views/pages/Home/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["MAZE_GENERATION_ALGORITHMS","RECURSIVE_DIVISION_EQUAL","label","execute","gridData","startRow","startCol","endRow","endCol","recursiveFunc","minRow","minCol","maxRow","maxCol","res","horizontalDivisionRowIndex","Math","round","verticalDivisionColIndex","row","isWall","length","update","$set","col","nonHoleSubDivisionWall","random","min","max","isVerticalWall","forEach","index","randomHolePosition","RECURSIVE_DIVISION_NON_EQUAL","BASIC_RANDOM_WALL","nRow","nCol","BASIC_RANDOM_DESERT","isDesert","QueueItem","value","next","this","Queue","head","tail","newItem","isEmpty","current","push","DIRS","getLocationNeighbors","location","gridNRow","gridNCol","dir","isGridLocationInBound","isGridLocationPassable","reverse","getCost","locationA","locationB","bfs","visitedCallback","frontier","cameFrom","Map","start","enqueue","set","dequeue","has","bfsEarlyExit","end","equal","PQItem","priority","PriorityQueue","prev","PATH_FINDING_ALGORITHMS","BFS","pathFindingAlgorithms","EARLY_EXIT_BFS","DIJKSTRA","costSoFar","newCost","get","GREEDY_BEST_FIRST_SEARCH","a","b","abs","A_STAR","DRAWING_ACTION_ADD_ITEM","DRAWING_ITEM_WALL","DRAWING_ITEM_DESERT","GridLocation","isVisited","isPathStep","isStart","isEnd","noAnimation","calculateDelayFromSpeed","speed","isMobileOrTabletDevice","navigator","userAgent","vendor","window","opera","test","substr","pathConstruct","FooterControls","selectedDrawingItem","onSelectDrawingItem","onSpeedChange","isVirtualizing","selectedMazePattern","onSelectMazePattern","onApplyMazePattern","mazeGeneratonAlgorithmOptions","useMemo","Object","entries","map","key","templateAreas","rowGap","columnGap","alignItems","textAlign","w","gridArea","fontWeight","disabled","onChange","ml","h","flexShrink","borderWidth","bgColor","borderColor","colorScheme","aria-label","width","defaultValue","boxSize","direction","onClick","memo","Legends","autoRows","gap","Footer","props","paddingLeft","paddingRight","visitedKeyframe","keyframes","desertVisitedKeyframe","startOrEndKeyframe","pathStepKeyframe","desertPathStepKeyframe","Cell","animation","onMouseDown","onMouseEnter","onMouseUp","handleMouseDown","useCallback","handleMouseEnter","handleMouseUp","border","userSelect","display","justifyContent","Grid","data","onMouseDownOnCell","onMouseEnterOnCell","onMouseUpOnCell","handleMouseDownOnTheContainerOfAllCells","event","stopPropagation","cursor","onMouseDownCapture","rowData","_extends","assign","target","i","arguments","source","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","height","fill","x","y","_ref5","_ref6","_ref7","_ref8","SvgLogo","_ref","svgRef","title","titleId","viewBox","xmlns","ref","id","ForwardRef","rotateKeyframes","Logo","logoStyle","borderRadius","mr","style","Header","selectedAlgorithm","onSelectedAlgorithmChange","onStartVisualization","onDone","onClearVisualizationResults","onClearAll","algorithmOptions","leftIcon","Check","Delete","Homepage","useState","setGridData","setStartRow","setStartCol","setEndRow","setEndCol","generateGridDataBasedOnScreensize","screenWidth","document","documentElement","clientWidth","screenHeight","clientHeight","headerHeight","getElementById","footerHeight","newGridWidth","newGridHeight","N_ROW","newNRow","newNCol","newStartRow","floor","newStartCol","newEndRow","newEndCol","Array","from","_","__","useEffect","setIsVirtualizing","isVisualizationDone","useRef","timerId","setSelectedAlgorithm","handleSelectAlgorithm","e","currentTarget","isChangingStartLocation","isChangingEndLocation","isDrawing","currentDrawingAction","setCurrentDrawingAction","setSelectedDrawingItem","timerDelayValue","handleSelectDrawingItem","handleSpeedChange","speedValue","handleChangeStartLocation","oldStartRow","oldStartCol","oldGridData","merge","handleChangeEndLocation","oldEndRow","oldEndCol","handleDrawing","drawingAction","handleMouseDownOnCell","handleMouseEnterOnCell","handleMouseUpOnCell","animateAlgorithm","visitedInOrder","Promise","resolve","array","resolveFunc","n","newGridData","visitedRow","visitedCol","setTimeout","animatePathConstruct","paths","prevState","stopVisualization","clearTimeout","handleClearVisualizationResults","handleClearAll","handleStartVisualization","algorithmFunc","visitedLocation","handleInstantPreview","startRowIndex","startColIndex","endRowIndex","endColIndex","windowWidth","innerWidth","handleWindowResize","currentWindowWidth","addEventListener","removeEventListener","handleDone","setSelectedMazePattern","handleSelectMazePatter","handleGenerateMaze","minHeight","padding","spacing","App","Home","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2e282837.chunk.js","sourcesContent":["import * as mazeGenerationAlgorithms from 'utils/algorithms/maze-generation';\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nexport type MazeGenerationAlgorithmKey =\n  | 'RECURSIVE_DIVISION_EQUAL'\n  | 'RECURSIVE_DIVISION_NON_EQUAL'\n  | 'BASIC_RANDOM_WALL'\n  | 'BASIC_RANDOM_DESERT';\n\nexport type MazeGenerationAlgorithms = Record<\n  MazeGenerationAlgorithmKey,\n  {\n    label: string;\n\n    /**\n     * Execute algorithm\n     */\n    execute(\n      gridData: GridLocation[][],\n      startRow: number,\n      startCol: number,\n      endRow: number,\n      endCol: number,\n    ): GridLocation[][];\n  }\n>;\n\nexport const MAZE_GENERATION_ALGORITHMS: MazeGenerationAlgorithms = {\n  RECURSIVE_DIVISION_EQUAL: {\n    label: 'Recursive equal division',\n    execute: mazeGenerationAlgorithms.recursiveDivisionEqual,\n  },\n  RECURSIVE_DIVISION_NON_EQUAL: {\n    label: 'Recursive non-equal division',\n    execute: mazeGenerationAlgorithms.recursiveDivisionNonEqual,\n  },\n  BASIC_RANDOM_WALL: {\n    label: 'Basic wall random',\n    execute: mazeGenerationAlgorithms.basicRandomWall,\n  },\n  BASIC_RANDOM_DESERT: {\n    label: 'Basic desert random',\n    execute: mazeGenerationAlgorithms.basicRandomDesert,\n  },\n};\n","/* eslint-disable no-shadow */\nimport update from 'immutability-helper';\n\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nconst recursiveDivisionEqual = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n): GridLocation[][] => {\n  const recursiveFunc = (\n    gridData: GridLocation[][],\n    startRow: number,\n    startCol: number,\n    endRow: number,\n    endCol: number,\n    minRow: number,\n    minCol: number,\n    maxRow: number,\n    maxCol: number,\n  ): GridLocation[][] => {\n    /**\n     * Every chamber has a width of one cell in either of the two directions\n     */\n    if (maxRow - minRow <= 1 || maxCol - minCol <= 1) return gridData;\n\n    let res = gridData;\n\n    /**\n     * Divide the large chamber into four smaller chambers separated by four walls\n     */\n    let horizontalDivisionRowIndex = Math.round(0.5 * (maxRow - minRow)) + minRow;\n    if (horizontalDivisionRowIndex === minRow) horizontalDivisionRowIndex += 1;\n    let verticalDivisionColIndex = Math.round(0.5 * (maxCol - minCol)) + minCol;\n    if (verticalDivisionColIndex === minCol) verticalDivisionColIndex += 1;\n\n    /**\n     * Create column division (aka vertical division)\n     */\n    for (let row = minRow; row <= maxRow; row += 1) {\n      if (\n        /**\n         * It's possible for the division wall to cover holes of other subchambers\n         * Such scenario will potentially cause our maze to be unsolvable.\n         * Therefore, if any head of the division contacts directly with an hole,\n         * we will let such head to be free of wall,\n         * hence the hole won't be covered\n         */\n        (row !== minRow || minRow === 0 || res[row - 1][verticalDivisionColIndex].isWall) &&\n        (row !== maxRow ||\n          maxRow === gridData.length - 1 ||\n          res[row + 1][verticalDivisionColIndex].isWall) &&\n        /**\n         * Skip the start/end location when creating division wall\n         * since they can't be wall locations\n         */\n        (row !== startRow || verticalDivisionColIndex !== startCol) &&\n        (row !== endRow || verticalDivisionColIndex !== endCol)\n      ) {\n        res = update(res, {\n          [row]: {\n            [verticalDivisionColIndex]: {\n              isWall: { $set: true },\n            },\n          },\n        });\n      }\n    }\n\n    /**\n     * Create row division (aka horizontal division)\n     */\n    for (let col = minCol; col <= maxCol; col += 1) {\n      if (\n        /**\n         * It's possible for the division wall to cover opened holes of other subchambers\n         * Such scenario will potentially cause our maze to be unsolvable.\n         * Therefore, if any head of the division contacts directly with an opened hole,\n         * we will let such head to be free of wall,\n         * hence the hole won't be covered\n         */\n        (col !== minCol || minCol === 0 || res[horizontalDivisionRowIndex][col - 1].isWall) &&\n        (col !== maxCol ||\n          maxCol === gridData[0].length - 1 ||\n          res[horizontalDivisionRowIndex][col + 1].isWall) &&\n        /**\n         * Skip the start/end location when creating division wall\n         * since they can't be wall locations\n         */\n        (horizontalDivisionRowIndex !== startRow || col !== startCol) &&\n        (horizontalDivisionRowIndex !== endRow || col !== endCol)\n      )\n        res = update(res, {\n          [horizontalDivisionRowIndex]: {\n            [col]: {\n              isWall: { $set: true },\n            },\n          },\n        });\n    }\n\n    /**\n     * Choose three of the four sub division walls at random, and open a one cell-wide hole at a random point in each of the three\n     *   - - - - -\n     *   |   0   |\n     *   | 1 * 3 |\n     *   |   2   |\n     *   - - - - -\n     */\n\n    // Choose three of the four sub division walls at random\n    const nonHoleSubDivisionWall = Math.round(Math.random() * 3);\n\n    const subDivisionWallsDescription: Array<{\n      min: number;\n      max: number;\n      isVerticalWall: boolean;\n    }> = [\n      { min: minRow, max: horizontalDivisionRowIndex - 1, isVerticalWall: true },\n      { min: minCol, max: verticalDivisionColIndex - 1, isVerticalWall: false },\n      { min: horizontalDivisionRowIndex + 1, max: maxRow, isVerticalWall: true },\n      { min: verticalDivisionColIndex + 1, max: maxCol, isVerticalWall: false },\n    ];\n\n    subDivisionWallsDescription.forEach(({ min, max, isVerticalWall }, index) => {\n      if (index === nonHoleSubDivisionWall) return;\n      if (min > max) return;\n\n      const randomHolePosition = Math.round(Math.random() * (max - min)) + min;\n\n      let row = -1;\n      let col = -1;\n\n      if (isVerticalWall) {\n        row = randomHolePosition;\n        col = verticalDivisionColIndex;\n      } else {\n        row = horizontalDivisionRowIndex;\n        col = randomHolePosition;\n      }\n\n      // Open a one cell-wide hole at a random point\n      res = update(res, {\n        [row]: {\n          [col]: {\n            isWall: { $set: false },\n          },\n        },\n      });\n    });\n\n    /**\n     * Recursively repeat the process on the subchambers\n     *   - - - - -\n     *   | 0 * 3 |\n     *   | * * * |\n     *   | 1 * 2 |\n     *   - - - - -\n     */\n    // Subchamber 0\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      minRow,\n      minCol,\n      horizontalDivisionRowIndex - 1,\n      verticalDivisionColIndex - 1,\n    );\n    // Subchamber 1\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      horizontalDivisionRowIndex + 1,\n      minCol,\n      maxRow,\n      verticalDivisionColIndex - 1,\n    );\n    // Subchamber 2\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      horizontalDivisionRowIndex + 1,\n      verticalDivisionColIndex + 1,\n      maxRow,\n      maxCol,\n    );\n    // Subchamber 3\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      minRow,\n      verticalDivisionColIndex + 1,\n      horizontalDivisionRowIndex - 1,\n      maxCol,\n    );\n    return res;\n  };\n\n  return recursiveFunc(\n    gridData,\n    startRow,\n    startCol,\n    endRow,\n    endCol,\n    0,\n    0,\n    gridData.length - 1,\n    gridData[0].length - 1,\n  );\n};\n\nexport default recursiveDivisionEqual;\n","/* eslint-disable no-shadow */\nimport update from 'immutability-helper';\n\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nconst recursiveDivisionNonEqual = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n): GridLocation[][] => {\n  const recursiveFunc = (\n    gridData: GridLocation[][],\n    startRow: number,\n    startCol: number,\n    endRow: number,\n    endCol: number,\n    minRow: number,\n    minCol: number,\n    maxRow: number,\n    maxCol: number,\n  ): GridLocation[][] => {\n    /**\n     * Every chamber has a width of one cell in either of the two directions\n     */\n    if (maxRow - minRow <= 1 || maxCol - minCol <= 1) return gridData;\n\n    let res = gridData;\n\n    /**\n     * Divide the large chamber into four smaller chambers separated by four walls\n     */\n    let horizontalDivisionRowIndex = Math.round(Math.random() * (maxRow - minRow)) + minRow;\n    if (horizontalDivisionRowIndex === minRow) horizontalDivisionRowIndex += 1;\n    let verticalDivisionColIndex = Math.round(Math.random() * (maxCol - minCol)) + minCol;\n    if (verticalDivisionColIndex === minCol) verticalDivisionColIndex += 1;\n\n    /**\n     * Create column division (aka vertical division)\n     */\n    for (let row = minRow; row <= maxRow; row += 1) {\n      if (\n        /**\n         * It's possible for the division wall to cover holes of other subchambers\n         * Such scenario will potentially cause our maze to be unsolvable.\n         * Therefore, if any head of the division contacts directly with an hole,\n         * we will let such head to be free of wall,\n         * hence the hole won't be covered\n         */\n        (row !== minRow || minRow === 0 || res[row - 1][verticalDivisionColIndex].isWall) &&\n        (row !== maxRow ||\n          maxRow === gridData.length - 1 ||\n          res[row + 1][verticalDivisionColIndex].isWall) &&\n        /**\n         * Skip the start/end location when creating division wall\n         * since they can't be wall locations\n         */\n        (row !== startRow || verticalDivisionColIndex !== startCol) &&\n        (row !== endRow || verticalDivisionColIndex !== endCol)\n      ) {\n        res = update(res, {\n          [row]: {\n            [verticalDivisionColIndex]: {\n              isWall: { $set: true },\n            },\n          },\n        });\n      }\n    }\n\n    /**\n     * Create row division (aka horizontal division)\n     */\n    for (let col = minCol; col <= maxCol; col += 1) {\n      if (\n        /**\n         * It's possible for the division wall to cover opened holes of other subchambers\n         * Such scenario will potentially cause our maze to be unsolvable.\n         * Therefore, if any head of the division contacts directly with an opened hole,\n         * we will let such head to be free of wall,\n         * hence the hole won't be covered\n         */\n        (col !== minCol || minCol === 0 || res[horizontalDivisionRowIndex][col - 1].isWall) &&\n        (col !== maxCol ||\n          maxCol === gridData[0].length - 1 ||\n          res[horizontalDivisionRowIndex][col + 1].isWall) &&\n        /**\n         * Skip the start/end location when creating division wall\n         * since they can't be wall locations\n         */\n        (horizontalDivisionRowIndex !== startRow || col !== startCol) &&\n        (horizontalDivisionRowIndex !== endRow || col !== endCol)\n      )\n        res = update(res, {\n          [horizontalDivisionRowIndex]: {\n            [col]: {\n              isWall: { $set: true },\n            },\n          },\n        });\n    }\n\n    /**\n     * Choose three of the four sub division walls at random, and open a one cell-wide hole at a random point in each of the three\n     *   - - - - -\n     *   |   0   |\n     *   | 1 * 3 |\n     *   |   2   |\n     *   - - - - -\n     */\n\n    // Choose three of the four sub division walls at random\n    const nonHoleSubDivisionWall = Math.round(Math.random() * 3);\n\n    const subDivisionWallsDescription: Array<{\n      min: number;\n      max: number;\n      isVerticalWall: boolean;\n    }> = [\n      { min: minRow, max: horizontalDivisionRowIndex - 1, isVerticalWall: true },\n      { min: minCol, max: verticalDivisionColIndex - 1, isVerticalWall: false },\n      { min: horizontalDivisionRowIndex + 1, max: maxRow, isVerticalWall: true },\n      { min: verticalDivisionColIndex + 1, max: maxCol, isVerticalWall: false },\n    ];\n\n    subDivisionWallsDescription.forEach(({ min, max, isVerticalWall }, index) => {\n      if (index === nonHoleSubDivisionWall) return;\n      if (min > max) return;\n\n      const randomHolePosition = Math.round(Math.random() * (max - min)) + min;\n\n      let row = -1;\n      let col = -1;\n\n      if (isVerticalWall) {\n        row = randomHolePosition;\n        col = verticalDivisionColIndex;\n      } else {\n        row = horizontalDivisionRowIndex;\n        col = randomHolePosition;\n      }\n\n      // Open a one cell-wide hole at a random point\n      res = update(res, {\n        [row]: {\n          [col]: {\n            isWall: { $set: false },\n          },\n        },\n      });\n    });\n\n    /**\n     * Recursively repeat the process on the subchambers\n     *   - - - - -\n     *   | 0 * 3 |\n     *   | * * * |\n     *   | 1 * 2 |\n     *   - - - - -\n     */\n    // Subchamber 0\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      minRow,\n      minCol,\n      horizontalDivisionRowIndex - 1,\n      verticalDivisionColIndex - 1,\n    );\n    // Subchamber 1\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      horizontalDivisionRowIndex + 1,\n      minCol,\n      maxRow,\n      verticalDivisionColIndex - 1,\n    );\n    // Subchamber 2\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      horizontalDivisionRowIndex + 1,\n      verticalDivisionColIndex + 1,\n      maxRow,\n      maxCol,\n    );\n    // Subchamber 3\n    res = recursiveFunc(\n      res,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      minRow,\n      verticalDivisionColIndex + 1,\n      horizontalDivisionRowIndex - 1,\n      maxCol,\n    );\n    return res;\n  };\n\n  return recursiveFunc(\n    gridData,\n    startRow,\n    startCol,\n    endRow,\n    endCol,\n    0,\n    0,\n    gridData.length - 1,\n    gridData[0].length - 1,\n  );\n};\n\nexport default recursiveDivisionNonEqual;\n","import update from 'immutability-helper';\n\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nconst basicWallRandom = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n): GridLocation[][] => {\n  let res = gridData;\n\n  const nRow = gridData.length;\n  const nCol = gridData[0].length;\n\n  for (let row = 0; row < nRow; row += 1) {\n    for (let col = 0; col < nCol; col += 1) {\n      if ((row !== startRow || col !== startCol) && (row !== endRow || col !== endCol)) {\n        const isWall = Math.random() < 0.25;\n        if (isWall) {\n          res = update(res, {\n            [row]: {\n              [col]: {\n                isWall: { $set: isWall },\n              },\n            },\n          });\n        }\n      }\n    }\n  }\n  return res;\n};\n\nexport default basicWallRandom;\n","import update from 'immutability-helper';\n\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nconst basicDesertRandom = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n): GridLocation[][] => {\n  let res = gridData;\n\n  const nRow = gridData.length;\n  const nCol = gridData[0].length;\n\n  for (let row = 0; row < nRow; row += 1) {\n    for (let col = 0; col < nCol; col += 1) {\n      if ((row !== startRow || col !== startCol) && (row !== endRow || col !== endCol)) {\n        const isDesert = Math.random() < 0.35;\n        if (isDesert) {\n          res = update(res, {\n            [row]: {\n              [col]: {\n                isDesert: { $set: isDesert },\n              },\n            },\n          });\n        }\n      }\n    }\n  }\n  return res;\n};\n\nexport default basicDesertRandom;\n","/* eslint-disable max-classes-per-file */\nexport class QueueItem<ValueType> {\n  value: ValueType;\n\n  next: QueueItem<ValueType> | null;\n\n  constructor(value: ValueType) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass Queue<ValueType> {\n  head: QueueItem<ValueType> | null;\n\n  tail: QueueItem<ValueType> | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  isEmpty() {\n    return this.head === null;\n  }\n\n  enqueue(value: ValueType) {\n    const newItem = new QueueItem(value);\n    if (this.isEmpty()) {\n      this.head = newItem;\n      this.tail = newItem;\n      return;\n    }\n\n    this.tail!.next = newItem;\n    this.tail = newItem;\n  }\n\n  dequeue(): ValueType | null {\n    if (this.isEmpty()) return null;\n\n    const res = this.head!.value;\n\n    if (this.head === this.tail) {\n      this.head = null;\n      this.tail = null;\n    } else {\n      this.head = this.head!.next;\n    }\n\n    return res;\n  }\n\n  traverse(): ValueType[] {\n    const res = [];\n    let current = this.head;\n    while (current) {\n      const { value } = current;\n      res.push(value);\n      current = current.next;\n    }\n    return res;\n  }\n}\n\nexport default Queue;\n","import GridLocation from 'utils/data-structures/location/GridLocation';\n\nexport const isGridLocationInBound = (\n  location: GridLocation | null | undefined,\n  gridNRow: number,\n  gridNCol: number,\n) => {\n  if (!location) return false;\n\n  const { row, col } = location;\n  return row >= 0 && row < gridNRow && col >= 0 && col < gridNCol;\n};\n\nexport const isGridLocationPassable = (location: GridLocation) => !location.isWall;\n\nconst DIRS = [\n  // TODO: Explain the below order\n  // East, West, North, South\n  { row: 0, col: 1 },\n  { row: 0, col: -1 },\n  { row: 1, col: 0 },\n  { row: -1, col: 0 },\n];\nexport const getLocationNeighbors = (gridData: GridLocation[][], location: GridLocation) => {\n  const gridNRow = gridData.length;\n  const gridNCol = gridData[0].length;\n\n  const res: GridLocation[] = [];\n\n  DIRS.forEach((dir) => {\n    const row = location.row + dir.row;\n    const col = location.col + dir.col;\n    const next = gridData[row]?.[col];\n\n    if (isGridLocationInBound(next, gridNRow, gridNCol) && isGridLocationPassable(next)) {\n      res.push(next);\n    }\n  });\n\n  // Ugly paths\n  if ((location.row + location.col) % 2 === 0) res.reverse();\n\n  return res;\n};\n\nexport const getCost = (locationA: GridLocation, locationB: GridLocation) => {\n  let res = 0;\n  if (locationA.isDesert) res += 2.5;\n  if (locationB.isDesert) res += 2.5;\n\n  return res === 0 ? 1 : res;\n};\n","import GridLocation from 'utils/data-structures/location/GridLocation';\nimport Queue from 'utils/data-structures/queue/Queue';\nimport { getLocationNeighbors } from 'utils/grid';\n\nimport { CameFrom } from './types';\n\nconst bfs = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  visitedCallback: (location: GridLocation) => void,\n): CameFrom => {\n  const frontier = new Queue<GridLocation>();\n  const cameFrom = new Map<GridLocation, GridLocation | null>();\n\n  const start = gridData[startRow][startCol];\n\n  frontier.enqueue(start);\n  cameFrom.set(start, null);\n\n  while (!frontier.isEmpty()) {\n    const current = frontier.dequeue()!;\n\n    if (visitedCallback) visitedCallback(current);\n\n    getLocationNeighbors(gridData, current).forEach((next) => {\n      if (!cameFrom.has(next)) {\n        cameFrom.set(next, current);\n        frontier.enqueue(next);\n      }\n    });\n  }\n\n  return cameFrom;\n};\nexport default bfs;\n","import GridLocation from 'utils/data-structures/location/GridLocation';\nimport Queue from 'utils/data-structures/queue/Queue';\nimport { getLocationNeighbors } from 'utils/grid';\n\nimport { CameFrom } from './types';\n\nconst bfsEarlyExit = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  visitedCallback: (location: GridLocation) => void,\n): CameFrom => {\n  const frontier = new Queue<GridLocation>();\n  const cameFrom = new Map<GridLocation, GridLocation | null>();\n\n  const start = gridData[startRow][startCol];\n  const end = gridData[endRow][endCol];\n\n  frontier.enqueue(start);\n  cameFrom.set(start, null);\n\n  while (!frontier.isEmpty()) {\n    const current = frontier.dequeue()!;\n\n    if (visitedCallback) visitedCallback(current);\n\n    if (current.equal(end)) break;\n\n    getLocationNeighbors(gridData, current).forEach((next) => {\n      if (!cameFrom.has(next)) {\n        cameFrom.set(next, current);\n        frontier.enqueue(next);\n      }\n    });\n  }\n\n  return cameFrom;\n};\n\nexport default bfsEarlyExit;\n","/* eslint-disable max-classes-per-file */\nclass PQItem<ValueType> {\n  value: ValueType;\n\n  priority: number;\n\n  next: PQItem<ValueType> | null;\n\n  constructor(value: ValueType, priority: number) {\n    this.value = value;\n    this.priority = priority;\n    this.next = null;\n  }\n}\n\nclass PriorityQueue<ValueType> {\n  head: PQItem<ValueType> | null;\n\n  tail: PQItem<ValueType> | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  isEmpty(): boolean {\n    return this.head === null;\n  }\n\n  enqueue(value: ValueType, priority: number) {\n    const newItem = new PQItem(value, priority);\n    if (this.isEmpty()) {\n      this.head = newItem;\n      this.tail = newItem;\n      return;\n    }\n\n    let prev = null;\n    let current = this.head;\n\n    while (current !== null) {\n      // A suitable inserting position is found\n      if (current.priority > priority) {\n        // Insert the item\n        if (prev !== null) prev.next = newItem;\n        else this.head = newItem;\n        newItem.next = current;\n        return;\n      }\n\n      prev = current;\n      current = current.next;\n    }\n\n    // If newItem has the highest priority\n    this.tail!.next = newItem;\n    this.tail = newItem;\n  }\n\n  dequeue(): ValueType | null {\n    if (this.isEmpty()) return null;\n\n    const res = this.head!.value;\n\n    this.head = this.head!.next;\n\n    if (this.head === null) this.tail = null;\n\n    return res;\n  }\n\n  traverse(): ValueType[] {\n    const res = [];\n    let current = this.head;\n    while (current) {\n      const { value } = current;\n      res.push(value);\n      current = current.next;\n    }\n    return res;\n  }\n}\n\nexport default PriorityQueue;\n","import * as pathFindingAlgorithms from 'utils/algorithms/path-finding';\nimport { CameFrom } from 'utils/algorithms/path-finding/types';\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nexport type PathFindingAlgorithmKey =\n  | 'BFS'\n  | 'EARLY_EXIT_BFS'\n  | 'GREEDY_BEST_FIRST_SEARCH'\n  | 'DIJKSTRA'\n  | 'A_STAR';\n\nexport type PathFindingAlgorithms = Record<\n  PathFindingAlgorithmKey,\n  {\n    label: string;\n\n    /**\n     * Execute algorithm\n     */\n    execute(\n      gridData: GridLocation[][],\n      startRow: number,\n      startCol: number,\n      endRow: number,\n      endCol: number,\n      visitedCallback?: (location: GridLocation) => void,\n    ): CameFrom;\n  }\n>;\n\nexport const PATH_FINDING_ALGORITHMS: PathFindingAlgorithms = {\n  BFS: {\n    label: 'BFS',\n    execute: pathFindingAlgorithms.bfs,\n  },\n  EARLY_EXIT_BFS: {\n    label: 'Early Exit BFS',\n    execute: pathFindingAlgorithms.bfsEarlyExit,\n  },\n  DIJKSTRA: {\n    label: 'Dijkstra',\n    execute: pathFindingAlgorithms.dijkstra,\n  },\n  GREEDY_BEST_FIRST_SEARCH: {\n    label: 'Greedy Best First Search',\n    execute: pathFindingAlgorithms.greedyBestFirstSearch,\n  },\n  A_STAR: {\n    label: 'A *',\n    execute: pathFindingAlgorithms.aStar,\n  },\n};\n","import GridLocation from 'utils/data-structures/location/GridLocation';\nimport PriorityQueue from 'utils/data-structures/queue/PriorityQueue';\nimport { getCost, getLocationNeighbors } from 'utils/grid';\n\nimport { CameFrom } from './types';\n\nconst dijkstra = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  visitedCallback: (location: GridLocation) => void,\n): CameFrom => {\n  const frontier = new PriorityQueue<GridLocation>();\n  const cameFrom = new Map<GridLocation, GridLocation | null>();\n  const costSoFar = new Map<GridLocation, number>();\n\n  const start = gridData[startRow][startCol];\n  const end = gridData[endRow][endCol];\n\n  frontier.enqueue(start, 0);\n  cameFrom.set(start, null);\n  costSoFar.set(start, 0);\n\n  while (!frontier.isEmpty()) {\n    const current = frontier.dequeue()!;\n\n    if (visitedCallback) visitedCallback(current);\n\n    if (current.equal(end)) break;\n\n    getLocationNeighbors(gridData, current).forEach((next) => {\n      const newCost = costSoFar.get(current)! + getCost(current, next);\n      if (!costSoFar.has(next) || newCost < costSoFar.get(next)!) {\n        costSoFar.set(next, newCost);\n        frontier.enqueue(next, newCost);\n        cameFrom.set(next, current);\n      }\n    });\n  }\n\n  return cameFrom;\n};\n\nexport default dijkstra;\n","import GridLocation from 'utils/data-structures/location/GridLocation';\nimport PriorityQueue from 'utils/data-structures/queue/PriorityQueue';\nimport { getLocationNeighbors } from 'utils/grid';\n\nimport { CameFrom } from './types';\n\nconst heuristic = (a: GridLocation, b: GridLocation): number => {\n  // Manhattan distance on a square grid\n  return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);\n};\n\nconst greedyBestFirstSearch = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  visitedCallback: (location: GridLocation) => void,\n): CameFrom => {\n  const frontier = new PriorityQueue<GridLocation>();\n  const cameFrom = new Map<GridLocation, GridLocation | null>();\n\n  const start = gridData[startRow][startCol];\n  const end = gridData[endRow][endCol];\n\n  frontier.enqueue(start, 0);\n  cameFrom.set(start, null);\n\n  while (!frontier.isEmpty()) {\n    const current = frontier.dequeue()!;\n\n    if (visitedCallback) visitedCallback(current);\n\n    if (current.equal(end)) break;\n\n    getLocationNeighbors(gridData, current).forEach((next) => {\n      if (!cameFrom.has(next)) {\n        const priority = heuristic(next, end);\n        frontier.enqueue(next, priority);\n        cameFrom.set(next, current);\n      }\n    });\n  }\n\n  return cameFrom;\n};\n\nexport default greedyBestFirstSearch;\n","import GridLocation from 'utils/data-structures/location/GridLocation';\nimport PriorityQueue from 'utils/data-structures/queue/PriorityQueue';\nimport { getCost, getLocationNeighbors } from 'utils/grid';\n\nimport { CameFrom } from './types';\n\nconst heuristic = (a: GridLocation, b: GridLocation): number => {\n  // Manhattan distance on a square grid\n  return Math.abs(a.row - b.row) + Math.abs(a.col - b.col);\n};\n\nconst aStar = (\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n  visitedCallback: (location: GridLocation) => void,\n): CameFrom => {\n  const frontier = new PriorityQueue<GridLocation>();\n  const cameFrom = new Map<GridLocation, GridLocation | null>();\n  const costSoFar = new Map<GridLocation, number>();\n\n  const start = gridData[startRow][startCol];\n  const end = gridData[endRow][endCol];\n\n  frontier.enqueue(start, 0);\n  cameFrom.set(start, null);\n  costSoFar.set(start, 0);\n\n  while (!frontier.isEmpty()) {\n    const current = frontier.dequeue()!;\n\n    if (visitedCallback) visitedCallback(current);\n\n    if (current.equal(end)) break;\n\n    getLocationNeighbors(gridData, current).forEach((next) => {\n      const newCost = costSoFar.get(current)! + getCost(current, next);\n      if (!costSoFar.has(next) || newCost < costSoFar.get(next)!) {\n        const priority = heuristic(next, end) + newCost;\n        costSoFar.set(next, newCost);\n        frontier.enqueue(next, priority);\n        cameFrom.set(next, current);\n      }\n    });\n  }\n\n  return cameFrom;\n};\n\nexport default aStar;\n","export const DRAWING_ACTION_ADD_ITEM = 'DRAWING_ACTION_ADD_ITEM';\n\nexport const DRAWING_ACTION_REMOVE_ITEM = 'DRAWING_ACTION_REMOVE_ITEM';\n\nexport type DrawingAction = typeof DRAWING_ACTION_ADD_ITEM | typeof DRAWING_ACTION_REMOVE_ITEM;\n\nexport const DRAWING_ITEM_WALL = 'DRAWING_ITEM_WALL';\n\nexport const DRAWING_ITEM_DESERT = 'DRAWING_ITEM_DESERT';\n\nexport type DrawingItem = typeof DRAWING_ITEM_WALL | typeof DRAWING_ITEM_DESERT;\n","class GridLocation {\n  row: number;\n\n  col: number;\n\n  isWall: boolean;\n\n  isDesert: boolean;\n\n  isVisited: boolean;\n\n  isPathStep: boolean;\n\n  isStart: boolean;\n\n  isEnd: boolean;\n\n  noAnimation: boolean;\n\n  constructor(\n    row: number,\n    col: number,\n    isWall: boolean,\n    isDesert: boolean,\n    isVisited: boolean,\n    isPathStep: boolean,\n    isStart: boolean,\n    isEnd: boolean,\n  ) {\n    this.row = row;\n    this.col = col;\n    this.isWall = isWall;\n    this.isDesert = isDesert;\n    this.isVisited = isVisited;\n    this.isPathStep = isPathStep;\n    this.isStart = isStart;\n    this.isEnd = isEnd;\n    this.noAnimation = false;\n  }\n\n  equal(value: GridLocation) {\n    return this.row === value.row && this.col === value.col;\n  }\n}\n\nexport default GridLocation;\n","import { MAX_DELAY } from 'constants/delay';\nimport { MAX_SPEED } from 'constants/speed';\n\nexport const calculateDelayFromSpeed = (speed: number): number => {\n  return MAX_DELAY * (1 - speed / MAX_SPEED);\n};\n","export const MAX_DELAY = 100; // in ms\nexport const MIN_DELAY = 0; // in ms\n","export const MAX_SPEED = 100; // in ms\nexport const MIN_SPEED = 0; // in ms\nexport const INITIAL_SPEED = 50; // in ms\n","/* eslint-disable no-useless-escape */\n/**\n * Credit: https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser#:~:text=Using%20navigator.userAgentData\n */\nexport const isMobileOrTabletDevice = (): boolean => {\n  let res = false;\n  // eslint-disable-next-line func-names\n  (function (a) {\n    if (\n      /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(\n        a,\n      ) ||\n      /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n        a.substr(0, 4),\n      )\n    )\n      res = true;\n  })(navigator.userAgent || navigator.vendor || (window as any).opera);\n  return res;\n};\n","/*\n * *****************************************************\n * Copyright (C) BoostCommerce.net\n *\n * This file is part of commerical BoostCommerce.net projects.\n *\n * This file can not be copied and/or distributed without the express\n * permission of BoostCommerce.net\n *\n * @Date:   Tue, Aug 17th 2021, 9:00:23 pm\n *\n * *****************************************************\n */\n\nimport GridLocation from './data-structures/location/GridLocation';\n\nexport const pathConstruct = (\n  cameFrom: Map<GridLocation, GridLocation | null>,\n  gridData: GridLocation[][],\n  startRow: number,\n  startCol: number,\n  endRow: number,\n  endCol: number,\n): GridLocation[] => {\n  const start = gridData[startRow][startCol];\n  const end = gridData[endRow][endCol];\n\n  let current = cameFrom.get(end);\n\n  if (!current) return [];\n\n  const res: GridLocation[] = [end];\n\n  while (current && !current.equal(start)) {\n    res.push(current);\n    current = cameFrom.get(current);\n  }\n\n  res.push(start);\n\n  res.reverse();\n\n  return res;\n};\n","import { SyntheticEvent, memo, useMemo } from 'react';\n\nimport {\n  Box,\n  Button,\n  Grid,\n  GridItem,\n  HStack,\n  Select,\n  Slider,\n  SliderFilledTrack,\n  SliderThumb,\n  SliderTrack,\n  Stack,\n  Text,\n} from '@chakra-ui/react';\n\nimport { MAZE_GENERATION_ALGORITHMS } from 'constants/algorithms/maze-generation';\nimport { DRAWING_ITEM_DESERT, DRAWING_ITEM_WALL } from 'constants/drawing';\nimport { INITIAL_SPEED, MAX_SPEED, MIN_SPEED } from 'constants/speed';\n\nexport interface Props {\n  selectedDrawingItem: string;\n  onSelectDrawingItem: (event: SyntheticEvent) => void;\n  onSpeedChange: (value: number) => void;\n  isVirtualizing: boolean;\n  selectedMazePattern: string;\n  onSelectMazePattern: (event: SyntheticEvent) => void;\n  onApplyMazePattern: () => void;\n}\n\nconst FooterControls = ({\n  selectedDrawingItem,\n  onSelectDrawingItem,\n  onSpeedChange,\n  isVirtualizing,\n  selectedMazePattern,\n  onSelectMazePattern,\n  onApplyMazePattern,\n}: Props): JSX.Element => {\n  const mazeGeneratonAlgorithmOptions = useMemo(\n    () =>\n      Object.entries(MAZE_GENERATION_ALGORITHMS).map(([key, { label }]) => (\n        <option key={key} value={key}>\n          {label}\n        </option>\n      )),\n    [],\n  );\n  return (\n    <Grid\n      templateAreas={[\n        `'drawingItemLabel' 'drawingItemInput' 'speedLabel' 'speedInput' 'mazeLabel' 'mazeInput'`,\n        `'drawingItemLabel drawingItemInput drawingItemInput' 'speedLabel speedInput speedInput' 'mazeLabel mazeInput mazeInput'`,\n      ]}\n      rowGap={4}\n      columnGap={[0, 4]}\n      alignItems=\"center\"\n      textAlign={['center', 'left']}\n      w={['full', 'unset']}\n    >\n      <GridItem gridArea=\"drawingItemLabel\">\n        <Text fontWeight=\"600\">Drawing item:</Text>\n      </GridItem>\n      <GridItem gridArea=\"drawingItemInput\">\n        <HStack>\n          <Select\n            w={['full', 60]}\n            value={selectedDrawingItem}\n            disabled={isVirtualizing}\n            onChange={onSelectDrawingItem}\n          >\n            <option value={DRAWING_ITEM_WALL}>Wall</option>\n            <option value={DRAWING_ITEM_DESERT}>Desert</option>\n          </Select>\n          <Box\n            ml={2}\n            w={4}\n            h={4}\n            flexShrink={0}\n            borderWidth=\"1px\"\n            bgColor={selectedDrawingItem === 'DRAWING_ITEM_WALL' ? 'gray.800' : 'orange.400'}\n            borderColor={selectedDrawingItem === 'DRAWING_ITEM_WALL' ? 'gray.700' : 'orange.300'}\n          />\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"speedLabel\">\n        <Text fontWeight=\"600\">Speed:</Text>\n      </GridItem>\n      <GridItem gridArea=\"speedInput\">\n        <Slider\n          colorScheme=\"cyan\"\n          aria-label=\"speed slider\"\n          width=\"full\"\n          min={MIN_SPEED}\n          max={MAX_SPEED}\n          defaultValue={INITIAL_SPEED}\n          onChange={onSpeedChange}\n        >\n          <SliderTrack>\n            <SliderFilledTrack />\n          </SliderTrack>\n          <SliderThumb boxSize={6} />\n        </Slider>\n      </GridItem>\n      <GridItem gridArea=\"mazeLabel\">\n        <Text fontWeight=\"600\">Maze pattern:</Text>\n      </GridItem>\n      <GridItem gridArea=\"mazeInput\">\n        <Stack direction={['column', 'row']}>\n          <Select\n            w={['full', 60]}\n            value={selectedMazePattern}\n            disabled={isVirtualizing}\n            onChange={onSelectMazePattern}\n          >\n            {mazeGeneratonAlgorithmOptions}\n          </Select>\n          <Button colorScheme=\"gray\" onClick={onApplyMazePattern}>\n            Apply\n          </Button>\n        </Stack>\n      </GridItem>\n    </Grid>\n  );\n};\n\nexport default memo(FooterControls);\n","import { memo } from 'react';\n\nimport { HStack, Box, Text, Grid, GridItem } from '@chakra-ui/react';\n\nconst Legends = () => {\n  return (\n    <Grid\n      autoRows=\"40px\"\n      templateAreas={[\n        `'start visited path' 'end desertVisited desertPath' 'wall . .' 'desert . .'`,\n        `'start end wall desert' '. . visited desertVisited' '. . path desertPath'`,\n      ]}\n      gap={4}\n      alignItems=\"center\"\n    >\n      <GridItem gridArea=\"start\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"red.400\"\n            borderColor=\"red.300\"\n            flexShrink={0}\n          />\n          <Text>Start</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"end\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"green.400\"\n            borderColor=\"green.300\"\n            flexShrink={0}\n          />\n          <Text>End</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"wall\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"gray.800\"\n            borderColor=\"gray.700\"\n            flexShrink={0}\n          />\n          <Text>Wall</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"desert\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"orange.400\"\n            borderColor=\"orange.300\"\n            flexShrink={0}\n          />\n          <Text>Desert</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"visited\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"blue.300\"\n            borderColor=\"blue.200\"\n            flexShrink={0}\n          />\n          <Text>Visited</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"desertVisited\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"orange.500\"\n            borderColor=\"orange.400\"\n            flexShrink={0}\n          />\n          <Text>Visited desert</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"path\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"yellow.300\"\n            borderColor=\"yellow.200\"\n            flexShrink={0}\n          />\n          <Text>Path</Text>\n        </HStack>\n      </GridItem>\n      <GridItem gridArea=\"desertPath\">\n        <HStack>\n          <Box\n            w={4}\n            h={4}\n            borderWidth=\"1px\"\n            bgColor=\"yellow.500\"\n            borderColor=\"yellow.400\"\n            flexShrink={0}\n          />\n          <Text>Path through desert</Text>\n        </HStack>\n      </GridItem>\n    </Grid>\n  );\n};\n\nexport default memo(Legends);\n","import { Stack, Spacer } from '@chakra-ui/react';\n\nimport FooterControls, { Props as FooterControlsProps } from './FooterControls';\nimport Legends from './Legends';\n\nconst Footer = (props: FooterControlsProps): JSX.Element => {\n  return (\n    <Stack\n      w=\"full\"\n      direction={['column', 'column', 'column', 'column', 'row']}\n      alignItems={['center', 'center', 'center', 'center', 'flex-start']}\n    >\n      {/* eslint-disable-next-line react/jsx-props-no-spreading */}\n      <FooterControls {...props} />\n      <Spacer paddingLeft={8} paddingRight={8} />\n      <Legends />\n    </Stack>\n  );\n};\n\nexport default Footer;\n","import { useCallback, memo } from 'react';\n\nimport { Box, keyframes } from '@chakra-ui/react';\n\nexport interface Props {\n  row: number;\n  col: number;\n  isVisited: boolean;\n  isPathStep: boolean;\n  isStart: boolean;\n  isEnd: boolean;\n  isWall: boolean;\n  isDesert: boolean;\n  noAnimation: boolean;\n  onMouseDown: (\n    row: number,\n    col: number,\n    isStart: boolean,\n    isEnd: boolean,\n    isWall: boolean,\n    isForest: boolean,\n  ) => void;\n  onMouseEnter: (\n    row: number,\n    col: number,\n    isStart: boolean,\n    isEnd: boolean,\n    isWall: boolean,\n    isForest: boolean,\n  ) => void;\n  onMouseUp: (row: number, col: number) => void;\n}\n\nconst visitedKeyframe = keyframes`\n  0% {\n    transform: scale(0.3);\n    background-color: var(--chakra-colors-purple-400);\n    border-radius: 50%;\n  }\n\n  50% {\n    background-color: var(--chakra-colors-cyan-500);\n  }\n\n  75% {\n    transform: scale(1.2);\n    background-color: var(--chakra-colors-blue-600);\n  }\n\n  100% {\n    transform: scale(1);\n    background-color: var(--chakra-colors-blue-300);\n  }\n`;\n\nconst desertVisitedKeyframe = keyframes`\n  0% {\n    transform: scale(0.3);\n    background-color: var(--chakra-colors-purple-400);\n    border-radius: 50%;\n  }\n\n  50% {\n    background-color: var(--chakra-colors-cyan-500);\n  }\n\n  75% {\n    transform: scale(1.2);\n    background-color: var(--chakra-colors-blue-600);\n  }\n\n  100% {\n    transform: scale(1);\n    background-color: var(--chakra-colors-orange-500);\n    border-color: var(--chakra-colors-orange-400);\n  }\n`;\n\nconst startOrEndKeyframe = keyframes`\n  0% {\n    transform: scale(1);\n  }\n\n  75% {\n    transform: scale(1.5);\n  }\n\n  100% {\n    transform: scale(1);\n  }\n`;\n\nconst pathStepKeyframe = keyframes`\n  0% {\n    transform: scale(0.6);\n    background-color: var(--chakra-colors-yellow-100);\n  }\n\n  50% {\n    transform: scale(1.2);\n    background-color: var(--chakra-colors-yellow-200);\n  }\n\n  100% {\n    transform: scale(1);\n    background-color: var(--chakra-colors-yellow-300);\n    border-color: var(--chakra-colors-yellow-200);\n  }\n`;\n\nconst desertPathStepKeyframe = keyframes`\n  0% {\n    transform: scale(0.6);\n    background-color: var(--chakra-colors-yellow-100);\n  }\n\n  50% {\n    transform: scale(1.2);\n    background-color: var(--chakra-colors-yellow-200);\n  }\n\n  100% {\n    transform: scale(1);\n    background-color: var(--chakra-colors-yellow-500);\n    border-color: var(--chakra-colors-yellow-400);\n  }\n`;\n\nconst Cell = ({\n  row,\n  col,\n  isVisited,\n  isPathStep,\n  isStart,\n  isEnd,\n  isWall,\n  isDesert,\n  noAnimation,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n}: Props): JSX.Element => {\n  /**\n   * Order of animation keyframe priority:\n   * startOrEndKeyframe > desertPathStepKeyframe > pathStepKeyframe > desertVisitedKeyframe > visitedKeyframe\n   */\n  let borderColor = 'blue.200';\n  let bgColor = 'white';\n\n  if (isStart) {\n    borderColor = 'red.400';\n    bgColor = 'red.300';\n  } else if (isEnd) {\n    borderColor = 'green.400';\n    bgColor = 'green.300';\n  } else if (isWall) {\n    borderColor = 'gray.800';\n    bgColor = 'gray.700';\n  } else if (isDesert) {\n    borderColor = 'orange.400';\n    bgColor = 'orange.300';\n  }\n\n  let animation;\n\n  if (isVisited) {\n    if (isDesert) animation = `${desertVisitedKeyframe} 1 1.5s ease-out alternate forwards`;\n    else animation = `${visitedKeyframe} 1 1.5s ease-out alternate forwards`;\n  }\n\n  if (isPathStep) {\n    animation = `${pathStepKeyframe} 1 1.5s ease-out alternate forwards`;\n    if (isDesert) animation = `${desertPathStepKeyframe} 1 1.5s ease-out alternate forwards`;\n  }\n\n  if ((isVisited || isPathStep) && (isStart || isEnd))\n    animation = `${startOrEndKeyframe} 1 1.5s ease-out alternate forwards`;\n\n  if (noAnimation) {\n    animation = '';\n    /**\n     * Color the cell using background color\n     * since colors came along with animation won't be applied\n     * when the animation is removed\n     */\n    if (isVisited && !isStart && !isEnd) {\n      bgColor = 'blue.300';\n      borderColor = 'blue.200';\n      if (isDesert) {\n        bgColor = 'orange.500';\n        borderColor = 'orange.400';\n      } else if (isWall) {\n        borderColor = 'gray.800';\n        bgColor = 'gray.700';\n      }\n    }\n    if (isPathStep && !isStart && !isEnd) {\n      bgColor = 'yellow.300';\n      borderColor = 'yellow.200';\n      if (isDesert) {\n        bgColor = 'yellow.500';\n        borderColor = 'yellow.400';\n      } else if (isWall) {\n        borderColor = 'gray.800';\n        bgColor = 'gray.700';\n      }\n    }\n  }\n\n  const handleMouseDown = useCallback(() => {\n    onMouseDown(row, col, isStart, isEnd, isWall, isDesert);\n  }, [row, col, isStart, isEnd, isWall, isDesert, onMouseDown]);\n\n  const handleMouseEnter = useCallback(() => {\n    onMouseEnter(row, col, isStart, isEnd, isWall, isDesert);\n  }, [row, col, isStart, isEnd, isWall, isDesert, onMouseEnter]);\n\n  const handleMouseUp = useCallback(() => {\n    onMouseUp(row, col);\n  }, [row, col, onMouseUp]);\n\n  return (\n    <Box\n      border=\"1px\"\n      userSelect=\"none\"\n      borderColor={borderColor}\n      w={6}\n      h={6}\n      display=\"inline-flex\"\n      justifyContent=\"center\"\n      alignItems=\"center\"\n      bgColor={bgColor}\n      animation={animation}\n      onMouseDown={handleMouseDown}\n      onMouseEnter={handleMouseEnter}\n      onMouseUp={handleMouseUp}\n    />\n  );\n};\n\nexport default memo(Cell);\n","import { SyntheticEvent, useCallback } from 'react';\n\nimport { Box, Flex } from '@chakra-ui/react';\n\nimport GridLocation from 'utils/data-structures/location/GridLocation';\n\nimport Cell from './Cell';\n\ninterface Props {\n  isVirtualizing: boolean;\n  data: GridLocation[][];\n  onMouseDownOnCell: (\n    row: number,\n    col: number,\n    isStart: boolean,\n    isEnd: boolean,\n    isWall: boolean,\n    isDesert: boolean,\n  ) => void;\n  onMouseEnterOnCell: (\n    row: number,\n    col: number,\n    isStart: boolean,\n    isEnd: boolean,\n    isWall: boolean,\n    isForest: boolean,\n  ) => void;\n  onMouseUpOnCell: () => void;\n}\n\nconst Grid = ({\n  isVirtualizing,\n  data,\n  onMouseDownOnCell,\n  onMouseEnterOnCell,\n  onMouseUpOnCell,\n}: Props): JSX.Element => {\n  const handleMouseDownOnTheContainerOfAllCells = useCallback(\n    (event: SyntheticEvent) => {\n      /**\n       * If the visualization process is running,\n       * prevent all attached events of all cells from happening\n       * by stop the further propagation of the mouse events\n       */\n      if (isVirtualizing) event.stopPropagation();\n    },\n    [isVirtualizing],\n  );\n  return (\n    <Box\n      cursor={isVirtualizing ? 'not-allowed' : ''}\n      onMouseDownCapture={handleMouseDownOnTheContainerOfAllCells}\n    >\n      {data.map((rowData, index) => (\n        // eslint-disable-next-line react/no-array-index-key\n        <Flex key={`row-${index}`}>\n          {rowData.map(\n            ({\n              row,\n              col,\n              isVisited,\n              isPathStep,\n              isStart,\n              isEnd,\n              isWall,\n              isDesert,\n              noAnimation,\n            }) => (\n              <Cell\n                key={`${row}-${col}`}\n                row={row}\n                col={col}\n                isVisited={isVisited}\n                isPathStep={isPathStep}\n                isStart={isStart}\n                isEnd={isEnd}\n                isDesert={isDesert}\n                isWall={isWall}\n                noAnimation={noAnimation}\n                onMouseDown={onMouseDownOnCell}\n                onMouseEnter={onMouseEnterOnCell}\n                onMouseUp={onMouseUpOnCell}\n              />\n            ),\n          )}\n        </Flex>\n      ))}\n    </Box>\n  );\n};\n\nexport default Grid;\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"rect\", {\n  width: 32,\n  height: 32,\n  fill: \"#63B3ED\"\n});\n\nvar _ref3 = /*#__PURE__*/React.createElement(\"rect\", {\n  x: 16,\n  width: 16,\n  height: 16,\n  fill: \"#68D391\"\n});\n\nvar _ref4 = /*#__PURE__*/React.createElement(\"rect\", {\n  y: 16,\n  width: 16,\n  height: 16,\n  fill: \"#FC8181\"\n});\n\nvar _ref5 = /*#__PURE__*/React.createElement(\"rect\", {\n  x: 16,\n  y: 16,\n  width: 8,\n  height: 8,\n  fill: \"#F6E05E\"\n});\n\nvar _ref6 = /*#__PURE__*/React.createElement(\"rect\", {\n  x: 16,\n  y: 16,\n  width: 16,\n  height: 16,\n  fill: \"#F6E05E\"\n});\n\nvar _ref7 = /*#__PURE__*/React.createElement(\"rect\", {\n  width: 8,\n  height: 8,\n  fill: \"#1A202C\"\n});\n\nvar _ref8 = /*#__PURE__*/React.createElement(\"rect\", {\n  x: 24,\n  y: 24,\n  width: 8,\n  height: 8,\n  fill: \"#F6AD55\"\n});\n\nfunction SvgLogo(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, [\"title\", \"titleId\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    width: 32,\n    height: 32,\n    viewBox: \"0 0 32 32\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8);\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgLogo);\nexport default __webpack_public_path__ + \"static/media/logo.d88fba2f.svg\";\nexport { ForwardRef as ReactComponent };","import { useMemo } from 'react';\n\nimport { Box, keyframes } from '@chakra-ui/react';\n\nimport { ReactComponent as LogoIcon } from 'assets/logo.svg';\n\nconst rotateKeyframes = keyframes`\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n`;\n\ninterface Props {\n  isVirtualizing: boolean;\n}\n\nconst Logo = ({ isVirtualizing }: Props): JSX.Element => {\n  const animation = isVirtualizing ? `${rotateKeyframes} infinite 0.5s linear` : '';\n\n  const logoStyle = useMemo(() => {\n    return isVirtualizing ? { borderRadius: '50%' } : {};\n  }, [isVirtualizing]);\n\n  return (\n    <Box mr={3}>\n      <Box animation={animation}>\n        <LogoIcon style={logoStyle} />\n      </Box>\n    </Box>\n  );\n};\n\nexport default Logo;\n","import { SyntheticEvent, memo, useMemo } from 'react';\n\nimport { CheckIcon, DeleteIcon } from '@chakra-ui/icons';\nimport { Button, Select, Stack, Text, Spacer } from '@chakra-ui/react';\n\nimport { PATH_FINDING_ALGORITHMS } from 'constants/algorithms/path-finding';\n\nimport Logo from './Logo';\n\nexport interface AlgorithmOption {\n  value: string;\n  label: string;\n}\n\ninterface Props {\n  selectedAlgorithm: string;\n  onSelectedAlgorithmChange: (event: SyntheticEvent) => void;\n  isVirtualizing: boolean;\n  onStartVisualization: () => void;\n  onDone: () => void;\n  onClearVisualizationResults: () => void;\n  onClearAll: () => void;\n}\n\nconst Header = ({\n  selectedAlgorithm,\n  onSelectedAlgorithmChange,\n  isVirtualizing,\n  onStartVisualization,\n  onDone,\n  onClearVisualizationResults,\n  onClearAll,\n}: Props) => {\n  /**\n   * A list of algorithm options\n   */\n  const algorithmOptions: AlgorithmOption[] = useMemo(() => {\n    return Object.entries(PATH_FINDING_ALGORITHMS).map(([value, { label }]) => ({\n      label,\n      value,\n    }));\n  }, []);\n  return (\n    <Stack\n      direction={['column', 'column', 'column', 'column', 'row']}\n      alignItems={['center', 'center', 'center', 'center']}\n    >\n      <Logo isVirtualizing={isVirtualizing} />\n      <Stack\n        direction={['column', 'column', 'row', 'row', 'row']}\n        alignItems=\"center\"\n        w={['full', 'full', 'unset']}\n      >\n        <Text fontWeight=\"600\">Algorithm:</Text>\n        <Select\n          w={['full', 'full', 60]}\n          value={selectedAlgorithm}\n          disabled={isVirtualizing}\n          onChange={onSelectedAlgorithmChange}\n        >\n          {algorithmOptions.map(({ value, label }) => (\n            <option key={value} value={value}>\n              {label}\n            </option>\n          ))}\n        </Select>\n        <Button\n          colorScheme=\"teal\"\n          onClick={onStartVisualization}\n          disabled={isVirtualizing}\n          w={['full', 'full', 'unset']}\n        >\n          Virtualize algorithm\n        </Button>\n        {isVirtualizing && (\n          <Button\n            colorScheme=\"green\"\n            leftIcon={<CheckIcon />}\n            onClick={onDone}\n            w={['full', 'full', 'unset']}\n          >\n            Done\n          </Button>\n        )}\n      </Stack>\n      <Spacer />\n      <Stack direction={['column', 'column', 'row', 'row', 'row']} w={['full', 'full', 'unset']}>\n        <Button\n          leftIcon={<DeleteIcon />}\n          colorScheme=\"purple\"\n          onClick={onClearVisualizationResults}\n        >\n          Clear visualization results\n        </Button>\n        <Button leftIcon={<DeleteIcon />} colorScheme=\"red\" onClick={onClearAll}>\n          <Text display={['none', 'block']}>Clear visualization results + walls + desert</Text>\n          <Text display={['block', 'none']}>Clear all</Text>\n        </Button>\n      </Stack>\n    </Stack>\n  );\n};\n\nexport default memo(Header);\n","import { useState, useCallback, useRef, useEffect } from 'react';\n\nimport { Box, Flex, VStack } from '@chakra-ui/react';\nimport merge from 'deepmerge';\nimport update from 'immutability-helper';\n\nimport {\n  MAZE_GENERATION_ALGORITHMS,\n  MazeGenerationAlgorithmKey,\n} from 'constants/algorithms/maze-generation';\nimport {\n  PATH_FINDING_ALGORITHMS,\n  PathFindingAlgorithmKey,\n} from 'constants/algorithms/path-finding';\nimport {\n  DrawingAction,\n  DrawingItem,\n  DRAWING_ACTION_ADD_ITEM,\n  DRAWING_ACTION_REMOVE_ITEM,\n  DRAWING_ITEM_DESERT,\n  DRAWING_ITEM_WALL,\n} from 'constants/drawing';\nimport {\n  // INITIAL_START_ROW,\n  // INITIAL_START_COL,\n  // INITIAL_END_ROW,\n  // INITIAL_END_COL,\n  // N_COL,\n  N_ROW,\n} from 'constants/grid';\nimport { INITIAL_SPEED } from 'constants/speed';\nimport GridLocation from 'utils/data-structures/location/GridLocation';\nimport { calculateDelayFromSpeed } from 'utils/delay';\nimport { isMobileOrTabletDevice } from 'utils/device-checking';\nimport { pathConstruct } from 'utils/path-construct';\nimport Footer from 'views/components/Footer';\nimport Grid from 'views/components/Grid';\nimport Header from 'views/components/Header';\n\nconst Homepage = () => {\n  /**\n   * gridData: The state of the grid's UI at a particular point of time\n   * It is usable by ReactJS to render the desired UI\n   */\n  const [gridData, setGridData] = useState<GridLocation[][]>([]);\n\n  /**\n   * startLocation: The starting grid location\n   */\n  const [startRow, setStartRow] = useState(-1);\n  const [startCol, setStartCol] = useState(-1);\n  /**\n   * endLocation: The ending grid location\n   */\n  const [endRow, setEndRow] = useState(-1);\n  const [endCol, setEndCol] = useState(-1);\n\n  const generateGridDataBasedOnScreensize = useCallback(() => {\n    const screenWidth = document.documentElement.clientWidth;\n    const screenHeight = document.documentElement.clientHeight;\n    const headerHeight = document.getElementById('header')!.clientHeight;\n    const footerHeight = document.getElementById('footer')!.clientHeight;\n    const viewportPaddings = 32 * 2;\n    const gridVerticalPadding = 32 * 2;\n\n    const minGridHeight = N_ROW * 24;\n\n    const newGridWidth = screenWidth - viewportPaddings;\n    const newGridHeight = Math.max(\n      screenHeight - viewportPaddings - headerHeight - footerHeight - gridVerticalPadding,\n      minGridHeight,\n    );\n    const newNRow = Math.round(newGridHeight / 24);\n    const newNCol = Math.round(newGridWidth / 24);\n\n    const newStartRow = Math.floor(newNRow / 2);\n    const newStartCol = Math.floor(newNCol / 3);\n    const newEndRow = newStartRow;\n    const newEndCol = newNCol - newStartCol - 1;\n\n    setStartRow(newStartRow);\n    setStartCol(newStartCol);\n    setEndRow(newEndRow);\n    setEndCol(newEndCol);\n\n    setGridData(\n      Array.from({ length: newNRow }, (_, row) =>\n        Array.from({ length: newNCol }, (__, col) => {\n          const isWall = false;\n          const isDesert = false;\n          const isVisited = false;\n          const isPathStep = false;\n          const isStart = row === newStartRow && col === newStartCol;\n          const isEnd = row === newEndRow && col === newEndCol;\n          return new GridLocation(\n            row,\n            col,\n            isWall,\n            isDesert,\n            isVisited,\n            isPathStep,\n            isStart,\n            isEnd,\n          );\n        }),\n      ),\n    );\n  }, []);\n\n  useEffect(() => {\n    generateGridDataBasedOnScreensize();\n  }, [generateGridDataBasedOnScreensize]);\n\n  /**\n   * isVirtualizing: A boolean state indicating if the visualization process is running\n   */\n  const [isVirtualizing, setIsVirtualizing] = useState(false);\n  /**\n   * isVisualizationDone: A boolean state indicating if the visualization process is done\n   * We implement this state using ref for below reasons:\n   * - The state isn't used to trigger re-render but only for keeping track purpose\n   * - Its consuming and mutating order have no dependencies on the state batching behavior of React\n   * in order for related logic to work properly.\n   * - The state is used along with startRow, startCol, endRow, endCol to determine whether an instant preview should occur.\n   * If a location changing happens on the start/end location after a completed visualization process and the board is dirty with the result,\n   * an instant preview will be occur.\n   * Watching the change of the start/end coordinations plus the isVisualizationDone status by useEffect is our go-to.\n   * However, if isVisualizationDone is implemented using useState, the effect will run immerdiately after a finished visualization\n   * (although there's no modification in location of the start/end location).\n   * On the other hand, this undesired consequence also stop the animation before its completion as the instant preview is triggered\n   * as long as the isVisualizationDone is true.\n   * Since the instant preview discard all animation and uses only direct stylings.\n   * When the instant preview is triggered before the completion of the animation, the animation will be stop in the middle of its work.\n   */\n  const isVisualizationDone = useRef(false);\n\n  /**\n   * The visualization process uses setTimeout to schedule UI state update\n   * By keep track of scheduled timer Is,\n   * we will be able to clear enqueued but not yet executed timer,\n   * and stop the visualization process completely when needed.\n   */\n  const timerId = useRef<NodeJS.Timeout | null>(null);\n\n  /**\n   * selectedAlgorithm: Selected path-finding algorithm\n   */\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState<PathFindingAlgorithmKey>('BFS');\n\n  const handleSelectAlgorithm = useCallback((e) => {\n    setSelectedAlgorithm(e.currentTarget.value);\n  }, []);\n\n  /**\n   * isChangingStartLocation: A boolean state indicating if user is dragging the start location to a new location\n   * isChangingEndLocation: A boolean state indicating if user is dragging the end location to a new location\n   * isDrawing: A boolean state indicating if user is drawing.\n   * (The drawing result will be wall or desert depending on the selected drawing item.)\n   *\n   * These 3 states correspondingly relate to 3 operations: start location changing, end location changing and grid drawing\n   * Such operations happen during 3 events on a cell: mousedown, mouseenter and mouseup.\n   * Since these 3 events happen separately, we make use of the 3 mentioned states\n   * to be able to aware of which operation is running during an individual event.\n   * Our event handler logic doesn't require a specific comsuming order of the 3 states in order to work properly,\n   * hence storing the states as refs is acceptable and won't create bugs.\n   * The main reason for the use of ref is performance boost.\n   * Storing the 3 states using React states (created via useState) will cause the mouseenter event handler to be re-created\n   * everytime they changed.\n   * Moreover, the handler is passed as props to every cells.\n   * Therefore, the function re-creation will cause all cells to re-render.\n   */\n  const isChangingStartLocation = useRef(false);\n  const isChangingEndLocation = useRef(false);\n  const isDrawing = useRef(false);\n\n  /**\n   * currentDrawingAction: Current drawing action\n   */\n  const [currentDrawingAction, setCurrentDrawingAction] =\n    useState<DrawingAction>(DRAWING_ACTION_ADD_ITEM);\n  /**\n   * selectedAlgorithm: Selected path-finding algorithm\n   */\n  const [selectedDrawingItem, setSelectedDrawingItem] = useState<DrawingItem>(DRAWING_ITEM_WALL);\n\n  /**\n   * timerDelayValue: Timer delay value\n   * We use setTimeout to schedule state update,\n   * which will prevent the state update from being batched but enqueued (rendered) right away\n   */\n  const timerDelayValue = useRef(calculateDelayFromSpeed(INITIAL_SPEED));\n\n  const handleSelectDrawingItem = useCallback((event) => {\n    setSelectedDrawingItem(event.currentTarget.value);\n  }, []);\n\n  const handleSpeedChange = useCallback((speedValue: number) => {\n    timerDelayValue.current = calculateDelayFromSpeed(speedValue);\n  }, []);\n\n  /**\n   * Update start location\n   */\n  const handleChangeStartLocation = useCallback((newStartRow: number, newStartCol: number) => {\n    setStartRow((oldStartRow) => {\n      setStartCol((oldStartCol) => {\n        setGridData((oldGridData) =>\n          update(\n            oldGridData,\n            /**\n             * Use deep merge to create the update object config\n             * Normal object destructuring will potentially overide properties\n             * since it's possible for oldStartRow and newStartRow to share the same value\n             * (such scenario can happen to oldStartCol and newStartCol to)\n             */\n            merge(\n              {\n                [oldStartRow]: { [oldStartCol]: { isStart: { $set: false } } },\n              },\n              { [newStartRow]: { [newStartCol]: { isStart: { $set: true } } } },\n            ),\n          ),\n        );\n        return newStartCol;\n      });\n      return newStartRow;\n    });\n  }, []);\n\n  /**\n   * Update end location\n   */\n  const handleChangeEndLocation = useCallback((newEndRow: number, newEndCol: number) => {\n    setEndRow((oldEndRow) => {\n      setEndCol((oldEndCol) => {\n        setGridData((oldGridData) =>\n          update(\n            oldGridData,\n            /**\n             * Use deep merge to create the update object config\n             * Normal object destructuring will potentially overide properties\n             * since it's possible for oldStartRow and newStartRow to share the same value\n             * (such scenario can happen to oldStartCol and newStartCol too)\n             */\n            merge(\n              {\n                [oldEndRow]: { [oldEndCol]: { isEnd: { $set: false } } },\n              },\n              { [newEndRow]: { [newEndCol]: { isEnd: { $set: true } } } },\n            ),\n          ),\n        );\n        return newEndCol;\n      });\n      return newEndRow;\n    });\n  }, []);\n\n  /**\n   * User can perform drawing action on the grid to create/remove a wall or a desert area\n   */\n  const handleDrawing = useCallback(\n    (row: number, col: number, drawingAction: DrawingAction) => {\n      const value = drawingAction === DRAWING_ACTION_ADD_ITEM;\n\n      if (selectedDrawingItem === DRAWING_ITEM_WALL)\n        setGridData((oldGridData) =>\n          update(oldGridData, {\n            [row]: {\n              [col]: {\n                isWall: { $set: value },\n                /**\n                 * Allow user to override a visited/path-step location with a wall\n                 */\n                isVisited: { $set: false },\n                isPathStep: { $set: false },\n              },\n            },\n          }),\n        );\n      else\n        setGridData((oldGridData) =>\n          update(oldGridData, {\n            [row]: {\n              [col]: {\n                isDesert: { $set: value },\n              },\n            },\n          }),\n        );\n    },\n    [selectedDrawingItem],\n  );\n\n  /**\n   * Handle mousedown event on a cell\n   */\n  const handleMouseDownOnCell = useCallback(\n    (\n      row: number,\n      col: number,\n      isStart: boolean,\n      isEnd: boolean,\n      isWall: boolean,\n      isDesert: boolean,\n    ) => {\n      /**\n       * Mobile\n       */\n      if (isMobileOrTabletDevice()) {\n        /**\n         * On mobile/tablet device, user can't perform drag & drop action to\n         * move the start/end location\n         * In such situation, we offer an alternative method for user to move the start/end location:\n         * Step 1: Touch the start or end location that need to be moved\n         * Step 2: Touch the intented destination location\n         * The below logic is to handle the step 2\n         */\n        if (isChangingStartLocation.current) {\n          /**\n           * A new location for start\n           * must not be ones that has already been occupied by a wall or the end location\n           */\n          if (!isEnd && !isWall) {\n            handleChangeStartLocation(row, col);\n            isChangingStartLocation.current = false;\n          }\n          return;\n        }\n        if (isChangingEndLocation.current) {\n          /**\n           * A new location for end\n           * must not be ones that has already been occupied by a wall or the start location\n           */\n          if (!isStart && !isWall) {\n            handleChangeEndLocation(row, col);\n            isChangingEndLocation.current = false;\n          }\n          return;\n        }\n      }\n\n      /**\n       * Desktop\n       */\n      if (isStart) {\n        isChangingStartLocation.current = true;\n      } else if (isEnd) {\n        isChangingEndLocation.current = true;\n      } else {\n        isDrawing.current = true;\n        let drawingAction: DrawingAction = DRAWING_ACTION_ADD_ITEM;\n        /**\n         * Starting to draw on a drawn cell will result in\n         * the removal of the applied drawing style of the targeted cell.\n         * Only cells of the same drawing item type are affected by the removal.\n         * E.g. A wall removal will only remove wall styling from wall cells.\n         * In contrast, drawing on a empty cell will apply the drawing style.\n         */\n        if (\n          (selectedDrawingItem === DRAWING_ITEM_DESERT && isDesert) ||\n          (selectedDrawingItem === DRAWING_ITEM_WALL && isWall)\n        ) {\n          drawingAction = DRAWING_ACTION_REMOVE_ITEM;\n        }\n        setCurrentDrawingAction(drawingAction);\n\n        /**\n         * Prevent user to draw a wall on a desert location\n         */\n        if (selectedDrawingItem === DRAWING_ITEM_WALL && isDesert) return;\n        /**\n         * Prevent user to draw a desert area on a wall location\n         */\n        if (selectedDrawingItem === DRAWING_ITEM_DESERT && isWall) return;\n        /**\n         * Apply the drawing action on the mousedown cell.\n         */\n\n        handleDrawing(row, col, drawingAction);\n      }\n    },\n    [handleDrawing, selectedDrawingItem, handleChangeStartLocation, handleChangeEndLocation],\n  );\n\n  /**\n   * Handle mouseenet event on a cell\n   */\n  const handleMouseEnterOnCell = useCallback(\n    (\n      row: number,\n      col: number,\n      isStart: boolean,\n      isEnd: boolean,\n      isWall: boolean,\n      isDesert: boolean,\n    ) => {\n      /**\n       * Mobile\n       */\n      if (isMobileOrTabletDevice()) {\n        return;\n      }\n\n      /**\n       * Desktop\n       */\n      if (isChangingStartLocation.current) {\n        /**\n         * A new location for start\n         * must not be ones that has already been occupied by a wall or the end location\n         */\n        if (!isEnd && !isWall) handleChangeStartLocation(row, col);\n      } else if (isChangingEndLocation.current) {\n        /**\n         * A new location for end\n         * must not be ones that has already been occupied by a wall or the start location\n         */\n        if (!isStart && !isWall) handleChangeEndLocation(row, col);\n      } else if (isDrawing.current) {\n        /**\n         * Prevent user to draw onto the start and end location\n         */\n        if (!isStart && !isEnd) {\n          /**\n           * Prevent user to draw a wall on a desert location\n           */\n          if (selectedDrawingItem === DRAWING_ITEM_WALL && isDesert) return;\n          /**\n           * Prevent user to draw a desert area on a wall location\n           */\n          if (selectedDrawingItem === DRAWING_ITEM_DESERT && isWall) return;\n          handleDrawing(row, col, currentDrawingAction);\n        }\n      }\n    },\n    [\n      handleChangeStartLocation,\n      handleChangeEndLocation,\n      handleDrawing,\n      currentDrawingAction,\n      selectedDrawingItem,\n    ],\n  );\n\n  /**\n   * Handle mouseenet event on a cell\n   */\n  const handleMouseUpOnCell = useCallback(() => {\n    /**\n     * Mobile\n     */\n    if (isMobileOrTabletDevice()) {\n      isDrawing.current = false;\n      return;\n    }\n\n    /**\n     * Desktop\n     */\n    isChangingStartLocation.current = false;\n    isChangingEndLocation.current = false;\n    isDrawing.current = false;\n  }, []);\n\n  /**\n   * Animate path-finding algorithm\n   */\n  const animateAlgorithm = useCallback(\n    (visitedInOrder: GridLocation[]): Promise<void> =>\n      new Promise<void>((resolve) => {\n        function recursiveFunc(array: GridLocation[], index: number, resolveFunc: () => void) {\n          const n = array.length;\n\n          if (index === n) {\n            resolveFunc();\n            return;\n          }\n\n          /**\n           * Skip the whole animation if user click the Done button\n           */\n          if (isVisualizationDone.current) {\n            setGridData((oldGridData) => {\n              let newGridData = update(oldGridData, {});\n              let i = index;\n              while (i < n) {\n                const { row: visitedRow, col: visitedCol } = array[i];\n                newGridData = update(newGridData, {\n                  [visitedRow]: {\n                    [visitedCol]: {\n                      isVisited: { $set: true },\n                      noAnimation: { $set: true },\n                    },\n                  },\n                });\n                i += 1;\n              }\n              return newGridData;\n            });\n            resolve();\n            return;\n          }\n\n          timerId.current = setTimeout(() => {\n            const { row: visitedRow, col: visitedCol } = array[index];\n            setGridData((oldGridData) =>\n              update(oldGridData, {\n                [visitedRow]: { [visitedCol]: { isVisited: { $set: true } } },\n              }),\n            );\n            recursiveFunc(array, index + 1, resolveFunc);\n          }, timerDelayValue.current);\n        }\n        recursiveFunc(visitedInOrder, 0, resolve);\n      }),\n    [],\n  );\n\n  /**\n   * Animate path constructing\n   */\n  const animatePathConstruct = useCallback((paths: GridLocation[]): Promise<void> => {\n    return new Promise<void>((resolve) => {\n      if (paths.length === 0) resolve();\n\n      function recursiveFunc(array: GridLocation[], index: number, resolveFunc: () => void) {\n        const n = array.length;\n\n        if (index === array.length) {\n          resolveFunc();\n          return;\n        }\n\n        /**\n         * Skip the whole animation if user click the Done button\n         */\n        if (isVisualizationDone.current) {\n          setGridData((oldGridData) => {\n            let newGridData = update(oldGridData, {});\n            let i = index;\n            while (i < n) {\n              const { row: visitedRow, col: visitedCol } = array[i];\n              newGridData = update(newGridData, {\n                [visitedRow]: {\n                  [visitedCol]: {\n                    isPathStep: { $set: true },\n                    noAnimation: { $set: true },\n                  },\n                },\n              });\n              i += 1;\n            }\n            return newGridData;\n          });\n          resolve();\n          return;\n        }\n\n        timerId.current = setTimeout(() => {\n          /**\n           * Use setTimeout to let state update be rendered instead of batched\n           */\n          const { row: visitedRow, col: visitedCol } = array[index];\n          setGridData((prevState) =>\n            update(prevState, {\n              [visitedRow]: { [visitedCol]: { isPathStep: { $set: true } } },\n            }),\n          );\n          recursiveFunc(array, index + 1, resolveFunc);\n        }, timerDelayValue.current);\n      }\n\n      recursiveFunc(paths, 0, resolve);\n    });\n  }, []);\n\n  /**\n   * Stop the visualization process\n   * by clear the timer and update process status\n   */\n  const stopVisualization = useCallback(() => {\n    // Clear enqueued timeout events\n    if (timerId.current !== null) {\n      clearTimeout(timerId.current);\n      timerId.current = null;\n    }\n\n    setIsVirtualizing(false);\n    isVisualizationDone.current = false;\n  }, []);\n\n  /**\n   * Clear only virtualized data\n   */\n  const handleClearVisualizationResults = useCallback(() => {\n    stopVisualization();\n\n    setGridData((oldGridData) =>\n      oldGridData.map((rowData) =>\n        rowData.map(\n          ({ row, col, isWall, isDesert, isStart, isEnd }) =>\n            new GridLocation(row, col, isWall, isDesert, false, false, isStart, isEnd),\n        ),\n      ),\n    );\n  }, [stopVisualization]);\n\n  /**\n   * Clear all (virtualized data + walls)\n   */\n  const handleClearAll = useCallback(() => {\n    stopVisualization();\n\n    setGridData((oldGridData) =>\n      oldGridData.map((rowData) =>\n        rowData.map(\n          ({ row, col, isStart, isEnd }) =>\n            new GridLocation(row, col, false, false, false, false, isStart, isEnd),\n        ),\n      ),\n    );\n  }, [stopVisualization]);\n\n  /**\n   * Start the visualization process\n   */\n  const handleStartVisualization = async () => {\n    handleClearVisualizationResults();\n\n    setIsVirtualizing(true);\n\n    const visitedInOrder: GridLocation[] = [];\n    const algorithmFunc = PATH_FINDING_ALGORITHMS[selectedAlgorithm].execute;\n\n    /**\n     * Calculate location mapping (location - location that it came from)\n     */\n    const cameFrom = algorithmFunc(\n      gridData,\n      startRow,\n      startCol,\n      endRow,\n      endCol,\n      (visitedLocation) => {\n        /**\n         * Save all visited location in visting order\n         */\n        visitedInOrder.push(visitedLocation);\n      },\n    );\n    /**\n     * Animate the visited location\n     */\n    await animateAlgorithm(visitedInOrder);\n\n    /**\n     * Generate list of locations that form the shortest path from start location to end location\n     */\n    const paths = pathConstruct(cameFrom, gridData, startRow, startCol, endRow, endCol);\n    /**\n     * Animate the locations that form the shortest path\n     */\n    await animatePathConstruct(paths);\n\n    setIsVirtualizing(false);\n    isVisualizationDone.current = true;\n  };\n\n  /**\n   * After a completed visualization process,\n   * if user change the start or end location,\n   * the grid will show the path-finding result corresponding with the new start/end location instantly without animation\n   */\n  const handleInstantPreview = useCallback(\n    (startRowIndex: number, startColIndex: number, endRowIndex: number, endColIndex: number) => {\n      setGridData((oldGridData) => {\n        const visitedInOrder: GridLocation[] = [];\n\n        const algorithmFunc = PATH_FINDING_ALGORITHMS[selectedAlgorithm].execute;\n\n        /**\n         * Init the new grid data with a non-virtualized data.\n         */\n        const newGridData = oldGridData.map((rowData) =>\n          rowData.map(\n            ({ row, col, isWall, isDesert, isStart, isEnd }) =>\n              new GridLocation(row, col, isWall, isDesert, false, false, isStart, isEnd),\n          ),\n        );\n\n        /**\n         * Calculate location mapping (location - location that it came from)\n         */\n        const cameFrom = algorithmFunc(\n          newGridData,\n          startRowIndex,\n          startColIndex,\n          endRowIndex,\n          endColIndex,\n          (visitedLocation) => {\n            visitedInOrder.push(visitedLocation);\n          },\n        );\n\n        /**\n         * Generate list of location that form the shortest path from start location to end location\n         */\n        const paths = pathConstruct(\n          cameFrom,\n          newGridData,\n          startRowIndex,\n          startColIndex,\n          endRowIndex,\n          endColIndex,\n        );\n\n        /**\n         * Update grid state to reflect all visited cells\n         * We can mutate newGridData since it's a newly created object which is independent to olGridData\n         */\n        visitedInOrder.forEach(({ row: visitedRow, col: visitedCol }) => {\n          newGridData[visitedRow][visitedCol].isVisited = true;\n          newGridData[visitedRow][visitedCol].noAnimation = true;\n        });\n\n        /**\n         * Update grid state to reflect all cells that form the shortest path\n         * We can mutate newGridData since it's a newly created object which is independent to olGridData\n         */\n        paths.forEach(({ row, col }) => {\n          newGridData[row][col].isPathStep = true;\n        });\n\n        return newGridData;\n      });\n    },\n    [selectedAlgorithm],\n  );\n\n  useEffect(() => {\n    /**\n     * Trigger instant preview when user modify the start/end location after a completed visualization\n     */\n    if (isVisualizationDone.current) handleInstantPreview(startRow, startCol, endRow, endCol);\n  }, [startRow, startCol, endRow, endCol, handleInstantPreview]);\n\n  const windowWidth = useRef(window.innerWidth);\n  /**\n   * Responsive feature\n   * When user resizes the browser window or the page is loaded on a small-screen device,\n   * we will:\n   * * Step 1: Stop any running visualization process\n   * * Step 2: Resizing the grid to match the screen size\n   */\n  const handleWindowResize = useCallback(() => {\n    const currentWindowWidth = window.innerWidth;\n    /**\n     * Scrolling on mobile device will trigger the window's resize event\n     * due to the showing/hidden behavior of the browser's URL bar.\n     * This behavior is undesirable.\n     * Our solution is to only run resizing logic when window's width change (not the height)\n     */\n    if (currentWindowWidth !== windowWidth.current) {\n      windowWidth.current = currentWindowWidth;\n\n      stopVisualization();\n\n      generateGridDataBasedOnScreensize();\n    }\n  }, [stopVisualization, generateGridDataBasedOnScreensize]);\n\n  useEffect(() => {\n    window.addEventListener('resize', handleWindowResize);\n    return () => {\n      window.removeEventListener('resize', handleWindowResize);\n    };\n  }, [handleWindowResize]);\n\n  const handleDone = useCallback(() => {\n    isVisualizationDone.current = true;\n  }, []);\n\n  const [selectedMazePattern, setSelectedMazePattern] = useState<MazeGenerationAlgorithmKey>(\n    'RECURSIVE_DIVISION_EQUAL',\n  );\n\n  const handleSelectMazePatter = useCallback((event) => {\n    setSelectedMazePattern(event.currentTarget.value);\n  }, []);\n\n  const handleGenerateMaze = useCallback(() => {\n    handleClearAll();\n\n    setGridData((oldGridData) => {\n      const mazedGridData = MAZE_GENERATION_ALGORITHMS[selectedMazePattern].execute(\n        oldGridData,\n        startRow,\n        startCol,\n        endRow,\n        endCol,\n      );\n\n      return mazedGridData;\n    });\n  }, [handleClearAll, selectedMazePattern, startRow, startCol, endRow, endCol]);\n\n  return (\n    <Flex minHeight=\"100vh\" alignItems=\"center\" justifyContent=\"center\" padding={8}>\n      <VStack spacing={6}>\n        <Box w=\"full\" id=\"header\">\n          <Header\n            selectedAlgorithm={selectedAlgorithm}\n            onSelectedAlgorithmChange={handleSelectAlgorithm}\n            isVirtualizing={isVirtualizing}\n            onStartVisualization={handleStartVisualization}\n            onDone={handleDone}\n            onClearVisualizationResults={handleClearVisualizationResults}\n            onClearAll={handleClearAll}\n          />\n        </Box>\n        <Grid\n          isVirtualizing={isVirtualizing}\n          data={gridData}\n          onMouseDownOnCell={handleMouseDownOnCell}\n          onMouseEnterOnCell={handleMouseEnterOnCell}\n          onMouseUpOnCell={handleMouseUpOnCell}\n        />\n        <Box w=\"full\" id=\"footer\">\n          <Footer\n            selectedDrawingItem={selectedDrawingItem}\n            onSelectDrawingItem={handleSelectDrawingItem}\n            isVirtualizing={isVirtualizing}\n            onSpeedChange={handleSpeedChange}\n            selectedMazePattern={selectedMazePattern}\n            onSelectMazePattern={handleSelectMazePatter}\n            onApplyMazePattern={handleGenerateMaze}\n          />\n        </Box>\n      </VStack>\n    </Flex>\n  );\n};\n\nexport default Homepage;\n","import Home from 'views/pages/Home';\n\nfunction App() {\n  return <Home />;\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\n\nimport { ChakraProvider } from '@chakra-ui/react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ChakraProvider>\n      <App />\n    </ChakraProvider>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}